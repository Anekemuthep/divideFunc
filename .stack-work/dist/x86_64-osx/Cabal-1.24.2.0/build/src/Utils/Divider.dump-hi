
==================== FINAL INTERFACE ====================
2018-04-28 04:36:45.920347 UTC

interface divideFunc-0.1.0.0-6nIeJmYpbdCINbxV1MHNbI:Utils.Divider 8002
  interface hash: a286123eea15787def0bae15ff77f358
  ABI hash: 1b73121f86b4db1f2878bf4b82ece08d
  export-list hash: da8b20e77f9fc53a75ae17391819890d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cc116b4fbfa7bde0171b8107f9c1cba4
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.Divider.getCustomAudience
  Utils.Divider.splitByTwoDots
  Utils.Divider.Producto
module dependencies: Lib.Prelude
package dependencies: array-0.5.1.1@array-0.5.1.1
                      async-2.1.1.1@async-2.1.1.1-8yywY4inVGRLJSCg60gBXj base-4.9.1.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      protolude-0.1.10@protolude-0.1.10-EbWghKT4Ra36YSCOzDFDKT
                      safe-0.3.15@safe-0.3.15-2Yd45VWFfdcKqKyispOifY
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00*
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Monoid 51cc9cd8c130d49ba96b7c2c2406022b
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Enum 3811281f7b5f26da514529cf3ed44009
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Read b6821365d2d5fa2155c9e910160e7f57
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Text.ParserCombinators.ReadPrec 5a182a8d6deb0f7d67aed5fab08a5cc0
import  -/  base-4.9.1.0:Text.Read.Lex 16199fac3c6c2d64cc7c268f3c0d2269
import  -/  Lib.Prelude 56b70d37d5e73ac2b3385463c9e02817
  exports: 7f97854b2cbe78cf55994970281b4148
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text f7d3d648ffeef1043fe2e522e7e66c1b
import  -/  text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Internal 9bfcbbbe07ecef48f631025a838df7da
cbb284c539d57f3b095aca81f5529c5b
  $fBoundedProducto ::
    GHC.Enum.Bounded a => GHC.Enum.Bounded (Utils.Divider.Producto a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dBounded :: GHC.Enum.Bounded a).
                  @ (Utils.Divider.Producto a)
                  (Utils.Divider.$fBoundedProducto_$cminBound @ a $dBounded)
                  (Utils.Divider.$fBoundedProducto_$cmaxBound @ a $dBounded) -}
cbb284c539d57f3b095aca81f5529c5b
  $fBoundedProducto_$cmaxBound ::
    GHC.Enum.Bounded a => Utils.Divider.Producto a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Enum.maxBound
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Enum.Bounded a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fBoundedProducto_$cminBound ::
    GHC.Enum.Bounded a => Utils.Divider.Producto a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),U(U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Enum.minBound
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Enum.Bounded a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fEqProducto ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Utils.Divider.Producto a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Utils.Divider.Producto a)
                  (Utils.Divider.$fEqProducto_$c== @ a $dEq)
                  (Utils.Divider.$fEqProducto_$c/= @ a $dEq) -}
cbb284c539d57f3b095aca81f5529c5b
  $fEqProducto_$c/= ::
    GHC.Classes.Eq a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes./=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fEqProducto_$c== ::
    GHC.Classes.Eq a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),U(U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.==
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fMonoidProducto ::
    GHC.Num.Num a => GHC.Base.Monoid (Utils.Divider.Producto a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Utils.Divider.Producto a)
                  (Utils.Divider.$fMonoidProducto_$cmempty @ a $dNum)
                  (Utils.Divider.$fMonoidProducto_$cmappend @ a $dNum)
                  (Utils.Divider.$fMonoidProducto_$cmconcat @ a $dNum) -}
93c899e685bcaa4eacd9c5036eb9f9bf
  $fMonoidProducto1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
cbb284c539d57f3b095aca81f5529c5b
  $fMonoidProducto2 ::
    GHC.Num.Num a =>
    Utils.Divider.Producto a -> Utils.Divider.Producto a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (ds :: Utils.Divider.Producto a)
                   (ds1 :: Utils.Divider.Producto a) ->
                 GHC.Num.*
                   @ a
                   $dNum
                   ds `cast` (Utils.Divider.N:Producto[0] <a>_R)
                   ds1 `cast` (Utils.Divider.N:Producto[0] <a>_R)) -}
5ab32aacf1c52ea47c291c019d187a75
  $fMonoidProducto3 :: GHC.Num.Num a => a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 GHC.Num.fromInteger @ a $dNum Utils.Divider.$fMonoidProducto1) -}
cbb284c539d57f3b095aca81f5529c5b
  $fMonoidProducto_$cmappend ::
    GHC.Num.Num a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> Utils.Divider.Producto a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Utils.Divider.$fMonoidProducto2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Utils.Divider.Producto a>_R
                 ->_R <Utils.Divider.Producto a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fMonoidProducto_$cmconcat ::
    GHC.Num.Num a =>
    [Utils.Divider.Producto a] -> Utils.Divider.Producto a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: [Utils.Divider.Producto a]) ->
                 let {
                   z :: a
                   = GHC.Num.fromInteger @ a $dNum Utils.Divider.$fMonoidProducto1
                 } in
                 letrec {
                   go :: [Utils.Divider.Producto a] -> Utils.Divider.Producto a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Utils.Divider.Producto a]) ->
                     case ds of wild {
                       [] -> z `cast` (Sym (Utils.Divider.N:Producto[0] <a>_R))
                       : y ys
                       -> (GHC.Num.*
                             @ a
                             $dNum
                             y `cast` (Utils.Divider.N:Producto[0] <a>_R)
                             (go ys) `cast` (Utils.Divider.N:Producto[0] <a>_R))
                            `cast`
                          (Sym (Utils.Divider.N:Producto[0] <a>_R)) }
                 } in
                 go eta) -}
cbb284c539d57f3b095aca81f5529c5b
  $fMonoidProducto_$cmempty ::
    GHC.Num.Num a => Utils.Divider.Producto a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
     Unfolding: InlineRule (0, True, True)
                Utils.Divider.$fMonoidProducto3
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto ::
    GHC.Classes.Ord a => GHC.Classes.Ord (Utils.Divider.Producto a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dOrd :: GHC.Classes.Ord a).
                  @ (Utils.Divider.Producto a)
                  (Utils.Divider.$fOrdProducto_$cp1Ord @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$ccompare @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$c< @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$c<= @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$c> @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$c>= @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$cmax @ a $dOrd)
                  (Utils.Divider.$fOrdProducto_$cmin @ a $dOrd) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$c< ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.<
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$c<= ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.<=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$c> ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.>
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$c>= ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.>=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$ccompare ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.compare
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R <GHC.Types.Ordering>_R) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$cmax ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> Utils.Divider.Producto a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.max
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$cmin ::
    GHC.Classes.Ord a =>
    Utils.Divider.Producto a
    -> Utils.Divider.Producto a -> Utils.Divider.Producto a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.min
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)
                 ->_R Sym (Utils.Divider.N:Producto[0] <a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fOrdProducto_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Utils.Divider.Producto a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Utils.Divider.$fEqProducto @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto ::
    GHC.Read.Read a => GHC.Read.Read (Utils.Divider.Producto a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dRead :: GHC.Read.Read a).
                  @ (Utils.Divider.Producto a)
                  (Utils.Divider.$fReadProducto_$creadsPrec @ a $dRead)
                  (Utils.Divider.$fReadProducto_$creadList @ a $dRead)
                  (Utils.Divider.$fReadProducto_$creadPrec @ a $dRead)
                  (Utils.Divider.$fReadProducto_$creadListPrec @ a $dRead) -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Utils.Divider.Producto a] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dRead :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Utils.Divider.Producto a]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.list1
                   @ (Utils.Divider.Producto a)
                   (Utils.Divider.$fReadProducto2 @ a $dRead)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Utils.Divider.Producto a>_R))
                   eta
                   @ b
                   eta1) -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto2 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (Utils.Divider.Producto a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U> -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [Utils.Divider.Producto a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Utils.Divider.Producto a]
                   (GHC.Read.list1
                      @ (Utils.Divider.Producto a)
                      (Utils.Divider.$fReadProducto2 @ a $dRead)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                <Utils.Divider.Producto a>_R))
                      GHC.Read.$fRead()5
                      @ [Utils.Divider.Producto a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Utils.Divider.Producto a]))) -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec [Utils.Divider.Producto a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Utils.Divider.$fReadProducto1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                         <[Utils.Divider.Producto a]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                    <[Utils.Divider.Producto a]>_R))) -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec (Utils.Divider.Producto a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Utils.Divider.$fReadProducto2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <Utils.Divider.Producto a>_R)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fReadProducto_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (Utils.Divider.Producto a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Utils.Divider.Producto a)
                   ((Utils.Divider.$fReadProducto2 @ a $dRead eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Utils.Divider.Producto a>_R)
                      @ (Utils.Divider.Producto a)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Utils.Divider.Producto a)))) -}
cbb284c539d57f3b095aca81f5529c5b
  $fShowProducto ::
    GHC.Show.Show a => GHC.Show.Show (Utils.Divider.Producto a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Utils.Divider.Producto a)
                  (Utils.Divider.$fShowProducto_$cshowsPrec @ a $dShow)
                  (Utils.Divider.$fShowProducto_$cshow @ a $dShow)
                  (Utils.Divider.$fShowProducto_$cshowList @ a $dShow) -}
02841a6eb77a687205d1c80e80b223dc
  $fShowProducto1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
0e0fe2f38ca38002fa0cb5f8ddd36837
  $fShowProducto2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
452f5b2cc8ffb75222ff6e10d56c69d5
  $fShowProducto3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getProducto = "#) -}
c23a73d95e342336cb88d868ba429e1d
  $fShowProducto4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Producto {"#) -}
7a32c8e455bd6d3343c2af8178a25acc
  $fShowProducto5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Utils.Divider.$fShowProducto2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cbb284c539d57f3b095aca81f5529c5b
  $fShowProducto_$cshow ::
    GHC.Show.Show a => Utils.Divider.Producto a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Utils.Divider.Producto a) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Utils.Divider.$fShowProducto4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Utils.Divider.$fShowProducto3
                      (GHC.Show.showsPrec
                         @ a
                         $dShow
                         Utils.Divider.$fShowProducto1
                         x `cast` (Utils.Divider.N:Producto[0] <a>_R)
                         Utils.Divider.$fShowProducto5))) -}
cbb284c539d57f3b095aca81f5529c5b
  $fShowProducto_$cshowList ::
    GHC.Show.Show a => [Utils.Divider.Producto a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Utils.Divider.Producto a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Utils.Divider.Producto a)
                   (Utils.Divider.$fShowProducto_$cshowsPrec
                      @ a
                      $dShow
                      Utils.Divider.$fShowProducto1)
                   eta
                   eta1) -}
cbb284c539d57f3b095aca81f5529c5b
  $fShowProducto_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Utils.Divider.Producto a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Utils.Divider.Producto a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Utils.Divider.$w$cshowsPrec @ a w ww1 w2 }) -}
824251f6e51f4100dffe9665c9fb5b35
  $tc'Producto :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3513973927961828610##
                   4759866053716094818##
                   Utils.Divider.$trModule
                   Utils.Divider.$tc'Producto1) -}
5f42b4f8f0cff670c10a30c6fa9c6e81
  $tc'Producto1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Producto"#) -}
b05e55fbda0575aeced6af9a16df8c14
  $tcProducto :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16351551446280882136##
                   12070510913335615736##
                   Utils.Divider.$trModule
                   Utils.Divider.$tcProducto1) -}
4cf1fcc9c6fd05155691a0480eac7c02
  $tcProducto1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Producto"#) -}
fa4622ffe6e30edfe25f9fa507ca5b27
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Utils.Divider.$trModule2
                   Utils.Divider.$trModule1) -}
e8bd789fc1ea5b9510ad28ee237a07df
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Utils.Divider"#) -}
812f9feabe5207afd626b56b46ce5960
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "divideFunc-0.1.0.0-6nIeJmYpbdCINbxV1MHNbI"#) -}
cbb284c539d57f3b095aca81f5529c5b
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Utils.Divider.Producto a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Utils.Divider.Producto a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       Utils.Divider.$fShowProducto1
                       w1 `cast` (Utils.Divider.N:Producto[0] <a>_R)
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Utils.Divider.$fShowProducto4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Utils.Divider.$fShowProducto3
                          (f (GHC.Base.++ @ GHC.Types.Char Utils.Divider.$fShowProducto2 x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
c8d3b80c51e4ad5a37c653f41bbd8535
  $wgetCustomAudience ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe
         (Data.Text.Internal.Text, Data.Text.Internal.Text)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [0] -}
cbb284c539d57f3b095aca81f5529c5b
  newtype Producto a = Producto {getProducto :: a}
2c5e1e539f014ec92ed377a28fa1e8cd
  getCustomAudience ::
    Data.Text.Internal.Text
    -> GHC.Base.Maybe
         (Data.Text.Internal.Text, Data.Text.Internal.Text)
  {- Arity: 1, Strictness: <S(LLS),1*U(U,U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 Utils.Divider.$wgetCustomAudience ww1 ww2 ww3 }) -}
55e754734fc9b69add1c0e51059cf99e
  getProducto :: Utils.Divider.Producto a -> a
  RecSel Left Utils.Divider.Producto
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Utils.Divider.getProducto1
                  `cast`
                (forall (a :: <*>_N).
                 <Utils.Divider.Producto a>_R
                 ->_R Utils.Divider.N:Producto[0] <a>_R) -}
1e7b9d9da5c2b5f98317b5b4c203b5fd
  getProducto1 ::
    Utils.Divider.Producto a -> Utils.Divider.Producto a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Utils.Divider.Producto a) -> ds) -}
4e18a17cb92962b8aabc17801f04dc9e
  splitByTwoDots :: [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [GHC.Types.Char]) ->
                 Utils.Divider.splitHelper
                   (GHC.Types.[] @ [GHC.Types.Char])
                   (GHC.Types.[] @ GHC.Types.Char)
                   x) -}
a8c96108481901211e433f8edaab5f8e
  splitHelper ::
    [[GHC.Types.Char]]
    -> [GHC.Types.Char] -> [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><S,1*U> -}
instance [safe] GHC.Enum.Bounded [Utils.Divider.Producto]
  = Utils.Divider.$fBoundedProducto
instance [safe] GHC.Classes.Eq [Utils.Divider.Producto]
  = Utils.Divider.$fEqProducto
instance [safe] GHC.Base.Monoid [Utils.Divider.Producto]
  = Utils.Divider.$fMonoidProducto
instance [safe] GHC.Classes.Ord [Utils.Divider.Producto]
  = Utils.Divider.$fOrdProducto
instance [safe] GHC.Read.Read [Utils.Divider.Producto]
  = Utils.Divider.$fReadProducto
instance [safe] GHC.Show.Show [Utils.Divider.Producto]
  = Utils.Divider.$fShowProducto
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

